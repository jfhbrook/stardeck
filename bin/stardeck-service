#!/usr/bin/env perl

use v5.40;
use warnings;

package main;

use Data::Dumper;
use IPC::Open2 'open2';
use JSON 'decode_json';
use threads;
use Time::HiRes 'usleep';

my $python_bin                  = 'python3';
my $active_window_poll_interval = 0.2;         # in seconds

# TODO: Load stardeck.yml

# TODO: Shared running flag, stop sub

# TODO: Capture sigint/sigterm and explicitly kill the pid. Hint:
#
# - https://www.perl.com/article/37/2013/8/18/Catch-and-Handle-Signals-in-Perl/
# - https://perldoc.perl.org/functions/kill
#
# Threads don't get individual signal handlers, that's process wide. I'll
# probably need to refactor this to send the pids to the main thread, and
# kill those in the signal handler.

my sub active_window_name {
    my $active_window = `kdotool getactivewindow`;
    `kdotool getwindowname $active_window`;
}

my sub poll_active_window {
    my $current = '';

    while (1) {

        # TODO: eval + error handling
        my $next = &active_window_name;
        if ( $next ne $current ) {
            my %event = (
                type => 'ActiveWindow',
                name => "${next}"
            );

            # TODO: Send event
            print Dumper( \%event );
        }
        $current = $next;
        usleep( $active_window_poll_interval * 10e6 );
    }

    # TODO: exit event
}

# TODO: These have a lot of copypasta. I should be able to create a subroutine
# that takes an array of arguments and a reference to a callback
my sub subscribe_plusdeck {
    my @command = (
        $python_bin, '-u', '-m', 'plusdeck.dbus.client', '--output', 'text',
        'subscribe'
    );

    my $pid = open2( my $out, my $in, @command );

    # TODO: emit PID
    # TODO: respect running flag
    # TODO: eval + error handling
    while (<$out>) {
        chomp;

        my %event = (
            type  => "PlusdeckState",
            state => $_
        );

        # TODO: send event to queue
        print Dumper( \%event );
    }

    # TODO: exit event
    # TODO: Move to external sub
    waitpid( $pid, 0 );
    $? == 0 or die("plusdeck subscribe exited with status $?");
}

my sub listen_crystalfontz {
    my @command = (
        $python_bin, '-u', '-m', 'crystalfontz.dbus.client', '--output',
        'json',      'listen'
    );

    my $pid = open2( my $out, my $in, @command );

    # TODO: emit PID
    # TODO: respect running flag
    # TODO: eval + error handling
    while (<$out>) {

        # {"type": "KeyActivityReport", "activity": "KEY_UP_PRESS"}
        my $event = decode_json $_;

        # TODO: Send event to queue
        print Dumper($event);
    }

    # TODO: exit event
    # TODO: Move to external sub
    waitpid( $pid, 0 );
    $? == 0 or die("crystalfontz listen exited with status $?");
}

my sub parse_actions {
    my @actions = ();
    while (@_) {
        my $identifier = shift;
        my $localized  = shift;
        my @pair       = ( $identifier, $localized );
        push( @actions, \@pair );
    }
    @actions;
}

my sub monitor_notifications {
    my @command = (
        'busctl', 'monitor', '--user',
        '--destination=org.freedesktop.Notifications',
        "--match=member='Notify'", '--json=short'
    );

    my $pid = open2( my $out, my $in, @command );

    # TODO: emit PID
    # TODO: respect running flag
    # TODO: eval + error handling
    while (<$out>) {

        # {
        #   "type":"method_call",
        #   "endian":"l",
        #   "flags":0,
        #   "version":1,
        #   "cookie":9,
        #   "timestamp-realtime":1744565025716135,
        #   "sender":":1.135",
        #   "destination":":1.45",
        #   "path":"/org/freedesktop/Notifications",
        #   "interface":"org.freedesktop.Notifications",
        #   "member":"Notify",
        #   "payload":{
        #     "type":"susssasa{sv}i",
        #     "data":[
        #       "notify-send",
        #       0,
        #       "",
        #       "Party time!",
        #       "It is time to party hard",
        #       ["dance", "Dance party!"],
        #       {
        #         "urgency":{
        #           "type":"y",
        #           "data":1
        #         },
        #         "sender-pid":{
        #           "type":"x"
        #           "data":129140
        #         }
        #       },
        #       -1
        #     ]
        #   }
        # }
        my $method_call = decode_json $_;
        my $payload     = $method_call->{'payload'};
        my $data        = $payload->{'data'};

        my $app_name       = $data->[0];
        my $replaces_id    = $data->[1];
        my $app_icon       = $data->[2];
        my $summary        = $data->[3];
        my $body           = $data->[4];
        my $actions        = $data->[5];
        my $hints          = $data->[6];
        my $expire_timeout = $data->[7];

        my %event = (
            type           => 'Notification',
            app_name       => $app_name,
            replaces_id    => $replaces_id,
            app_icon       => $app_icon,
            summary        => $summary,
            body           => $body,
            actions        => $actions,
            hints          => $hints,
            expire_timeout => $expire_timeout
        );

        # TODO: send event to queue
        print Dumper( \%event );
    }

    # TODO: exit event
    # TODO: Move to external sub
    waitpid( $pid, 0 );
    $? == 0 or die("busctl exited with status $?");
}

my $poll         = threads->create( \&poll_active_window );
my $subscription = threads->create( \&subscribe_plusdeck );
my $listener     = threads->create( \&listen_crystalfontz );
my $monitor      = threads->create( \&monitor_notifications );

$poll->join();
$subscription->join();
$listener->join();
$monitor->join();
