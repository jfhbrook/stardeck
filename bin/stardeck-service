#!/usr/bin/env perl

use v5.40;
use threads;
use threads::shared;
use warnings;

use Data::Dumper;
use IPC::Open2 'open2';
use JSON 'decode_json';
use Thread::Queue;
use Time::HiRes 'usleep';

package main;

my $python_bin                  = 'python3';
my $active_window_poll_interval = 0.2;         # in seconds

# TODO: Load stardeck.yml

my $running : shared = 1;

sub stop_workers {
    $running = 0;
}

my @pids;

# TODO: Capture sigint/sigterm and explicitly kill the pid. Hint:
#
# - https://www.perl.com/article/37/2013/8/18/Catch-and-Handle-Signals-in-Perl/
# - https://perldoc.perl.org/functions/kill
#
# Threads don't get individual signal handlers, that's process wide. I'll
# probably need to refactor this to send the pids to the main thread, and
# kill those in the signal handler.

# waitpid( $pid, 0 );
# $? == 0 or die("plusdeck subscribe exited with status $?");

my $main_commands = Thread::Queue->new();

my sub active_window_worker {
    my $current = '';

    while ($running) {
        my $window = `kdotool getactivewindow`;
        my $next   = `kdotool getwindowname $window`;
        if ( $next ne $current ) {
            my %event = (
                type => 'ActiveWindow',
                name => "${next}"
            );

            $main_commands->enqueue( \%event );
        }
        $current = $next;

        if ($running) {
            usleep( $active_window_poll_interval * 10e6 );
        }
    }
}

my sub listen {
    my $name    = shift;
    my $command = shift;
    my $map_sub = shift;

    my $pid = open2( my $out, my $in, @$command );

    my %pid_event = (
        type        => 'StartProcess',
        thread_name => $name,
        pid         => $pid
    );

    $main_commands->enqueue( \%pid_event );

    while ($running) {
        my $line = <$out>;
        chomp $line;

        my $event;

        # TODO: Better error handling?
        eval { $event = $map_sub->($line); };

        if ($event) {
            $main_commands->enqueue($event);
        }
    }

    my %exit_event = (
        type        => 'ThreadExit',
        thread_name => $name
    );

    $main_commands->enqueue( \%exit_event );
}

my sub plusdeck_state_worker {
    my @command = (
        $python_bin, '-u', '-m', 'plusdeck.dbus.client', '--output', 'text',
        'subscribe'
    );

    &listen(
        'plusdeck_state',
        \@command,
        sub {
            my %event = (
                type  => "PlusdeckState",
                state => $_
            );
            \%event;
        }
    );
}

my sub crystalfontz_reports_worker {
    my @command = (
        $python_bin, '-u', '-m', 'crystalfontz.dbus.client', '--output',
        'json',      'listen'
    );

    # {"type": "KeyActivityReport", "activity": "KEY_UP_PRESS"}
    &listen( 'crystalfontz_reports', \@command, sub { decode_json $_; } );
}

my sub map_notification_actions {
    my @actions = ();
    while (@_) {
        my $identifier = shift;
        my $localized  = shift;
        my @pair       = ( $identifier, $localized );
        push( @actions, \@pair );
    }
    \@actions;
}

my sub map_notifications {

    # {
    #   "type":"method_call",
    #   "endian":"l",
    #   "flags":0,
    #   "version":1,
    #   "cookie":9,
    #   "timestamp-realtime":1744565025716135,
    #   "sender":":1.135",
    #   "destination":":1.45",
    #   "path":"/org/freedesktop/Notifications",
    #   "interface":"org.freedesktop.Notifications",
    #   "member":"Notify",
    #   "payload":{
    #     "type":"susssasa{sv}i",
    #     "data":[
    #       "notify-send",
    #       0,
    #       "",
    #       "Party time!",
    #       "It is time to party hard",
    #       ["dance", "Dance party!"],
    #       {
    #         "urgency":{
    #           "type":"y",
    #           "data":1
    #         },
    #         "sender-pid":{
    #           "type":"x"
    #           "data":129140
    #         }
    #       },
    #       -1
    #     ]
    #   }
    # }
    my $method_call = decode_json $_;
    my $payload     = $method_call->{'payload'};
    my $data        = $payload->{'data'};

    my $app_name       = $data->[0];
    my $replaces_id    = $data->[1];
    my $app_icon       = $data->[2];
    my $summary        = $data->[3];
    my $body           = $data->[4];
    my $actions        = &map_notification_actions( $data->[5] );
    my $hints          = $data->[6];
    my $expire_timeout = $data->[7];

    # TODO: Add timestamp
    my %event = (
        type           => 'Notification',
        app_name       => $app_name,
        replaces_id    => $replaces_id,
        app_icon       => $app_icon,
        summary        => $summary,
        body           => $body,
        actions        => $actions,
        hints          => $hints,
        expire_timeout => $expire_timeout
    );

    \%event;
}

my sub notifications_worker {
    my @command = (
        'busctl', 'monitor', '--user',
        '--destination=org.freedesktop.Notifications',
        "--match=member='Notify'", '--json=short'
    );

    &listen( 'notifications', \@command, \&map_notifications );
}

my $active_window_thread  = threads->create( \&active_window_worker );
my $plusdeck_state_thread = threads->create( \&plusdeck_state_worker );
my $crystalfontz_reports_thread =
  threads->create( \&crystalfontz_reports_worker );
my $notifications_thread = threads->create( \&notifications_worker );

while ( my $event = $main_commands->dequeue() ) {

    # TODO: Handle StartProcess event
    # TODO: Handle ThreadExit event
    # TODO: Handle ActiveWindow event
    # TODO: Handle PlusdeckState event
    # TODO: Handle KeyActivityReport event
    # TODO: Handle Notification event
    print Dumper($event);
}

$active_window_thread->join();
$plusdeck_state_thread->join();
$crystalfontz_reports_thread->join();
$notifications_thread->join();
